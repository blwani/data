# 1. 리액티브 프로그래밍


## 1.1. 리액티브 프로그래밍
- 비동기 데이터흐름에 기반을 둔 프로그래밍 패러다임
- 이벤트 기반
    
## 1.2. 마이크로소프트 리액티브 익스텐션
- Rx
    - Microsoft .NET의 Reactive Extension
- 에릭 마이어는 함수형 리액티브 프로그래밍에서 영감을 얻어 Microsoft의 Rx 라이브러리 디자인
- Observable Sequence 로 비동기와 이벤트 기반의 프로그램을 개발
- Observable을 이용해 비동기 데이터 스트림을 모델링하며, LINQ를 통해 Observable을 질의할 수 있으며, 스케쥴러를 이용해 동시성문제 해결.

    
- 닷넷 옵저버블
    - 풀/동기/상호반응
        - 단일반환값 : T
        - 복수반환값 : IEnumerable<T>
    - 푸시/비동기/리액티브
        - 단일반환값 : Task<T>
        - 복수반환값 : IObservable<T>
- 개발자는결과를 요청하고 기다리는 대신, 단순히 결과를 요청하고 값이 준비되면 알림을 받는다. 개발자는 발생할 이벤트에 대해 명확한 반응 시퀀스를 제공한다. 각 이벤트에서 개발자는 반응을 제공한다.
  - 예를들어 사용자가 로그인을 요청하고 사용자 이름과 비밀버호를 포함한 양식을 제출한다고 하면, 애플리케이션은 로그인을 위한 네트워크호출을 실행하고 무슨일이 일어날지를 서술한다.
    - 성공메시지를 출력하고 사용자 프로필을 저장
    - 에러미시지 출력
  - 푸시 방식에서 알 수 있듯이 개발자는 결과를 기다리지 않는다. 결과가 도착을 하면 알림을 받는다. (그동안 개발자는 다른일을 할 수 있다.)
    - 프로그레스 다이얼로그 출력
    - 향후 로그인을 위한 사용자 이름과 비밀번호 저장
    - 로그인에 성공하자마자 시간이 걸릴 작업들을 먼저 진행

## 1.3. RxJava
- 2012년 넷플릭스에서 REST 호출 최적화를 위해 리액티브 선택.
  - 닷넷의 Rx를 JVM에 이식.
    - 자바뿐만 아니라 closure, groovy, scala에서도 가능.
  - 2013년 2월 벤크리스텐슨과 자파르 후사인이 넷플릭스 기술블로그에서 처음으로 RxJava 소개
  - 핵심개념은 다음과 같다
    - 서버 성능을 더욱 활용하기 위한 손쉬운 동시성
    - 손쉬운 조건부 비동기 실행
    - 콜백 지옥을 벗어나기 위한 적절한 방법
    - 리액티브 접근법

- 닷넷의 관점에서 RxJava 의 업저버블 Push 방식은 닷넷 이터러블 pull 방식과 동일.
  - 풀 방식은 블로킹대기방식. 소비자는 소스에서 값을 가져가며, 생산자가 새로운 값을 제공하기 전까지 스레드를 블로킹함.
  - 푸시는 구독하고 반응하는 방식으로 동작. 소비자는 새로운 값의 발행을 구독.
  - 생산자는 새로운 값이 준비되면 값을 푸쉬하고 이를 소비자에게 알림.
  - 이 시점에서 소비자는 이를 소비. 논리적, 실용적 관점에서 푸시 방식은 필요한 정보가 동기적으로나 비동기적으로 전달되면 개발자는 간단히 무시할 수 있으므로 더욱 유연하다.

- RxJava 는 무엇이 다른가?
  - 옵저버패턴의 확장
    - 생산자는 더 이상 가능한 데이터가 없다는 사실을 onCompleted()로 알릴 수 있다.
    - 생산자는 에러가 발생했음을 onError()로 알릴 수 있다.
    - Rx자바의 옵저버블은 중첩 방식에서 벗어나 개발자를 콜백 지옥에서 구한다.
|패턴|단일반환값|복수반환값|
|------|---|---|
|동기|T getData()|Iterable<T> getData()|
|비동기|Future<T> getData()|Observable<T> getData()|